#include QMK_KEYBOARD_H

// Layer definitions
enum layers {
    _BASE,
    _LAYER1,
    _LAYER2,
    _LAYER3
};

uint8_t display_layer = _BASE;  // Tracks the currently displayed layer
uint8_t active_layer = _BASE;   // Tracks the actually active layer
enum custom_keycodes {
    GIT_ADD = SAFE_RANGE,
    GIT_COMMIT,
    OPEN_CHATGPT,
    GIT_PUSH,
    MUTE
};

static uint32_t mute_timer = 0;
static bool mute_key_pressed = false;

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    if (record->event.pressed) {
        switch (keycode) {
            case GIT_ADD:
                if (active_layer == _BASE) {
                    SEND_STRING("git add .\n");
                    return false; // Prevent further processing
                }
                return true; // allow other layers to be processed

            case GIT_COMMIT:
                if (active_layer == _BASE) {
                    SEND_STRING("git commit -m \".\"\n");
                    return false; // Prevent further processing
                }
                return true; // allow other layers to be processed

            case GIT_PUSH:
                if (active_layer == _BASE) {
                    SEND_STRING("git push\n");
                    return false; // Prevent further processing
                }
                return true; // allow other layers to be processed

            case OPEN_CHATGPT: {
                if (active_layer == _BASE) {
                    SEND_STRING("git status\n");
                    return false; // allow other layers to be processed
                }
                return true;  // Prevent further processing of OPEN_CHATGPT
            }

            case MUTE:
                mute_key_pressed = true;
                mute_timer = timer_read32();
                return false; 

            default:
                return true;
        }
    } else {
        if (keycode == MUTE) {
            if (mute_key_pressed) {
                mute_key_pressed = false;
                if (timer_elapsed32(mute_timer) > 1000) {
                    SEND_STRING(SS_TAP(X_MUTE));
                } else {
                    display_layer = (display_layer + 1) % 4;

                    layer_off(active_layer);
                    active_layer = display_layer;
                    layer_on(active_layer);
                }
            }
            return false;
        }
    }
    return true;  // Always return true unless you're explicitly preventing the keycode
}

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_BASE] = LAYOUT(
        GIT_ADD, GIT_COMMIT, OPEN_CHATGPT,
        GIT_PUSH, MUTE
    ),
    [_LAYER1] = LAYOUT(
        KC_A, KC_B, KC_C,
        KC_D, MUTE
    ),
    [_LAYER2] = LAYOUT(
        KC_E, KC_F, KC_G,
        KC_H, MUTE
    ),
    [_LAYER3] = LAYOUT(
        KC_I, KC_J, KC_K,
        KC_L, MUTE
    )
};

// Encoder remains for volume control
const uint16_t PROGMEM encoder_map[][1][2] = {
    [_BASE]   = { ENCODER_CCW_CW(KC_VOLD, KC_VOLU) },
    [_LAYER1] = { ENCODER_CCW_CW(KC_LEFT, KC_RIGHT) },
    [_LAYER2] = { ENCODER_CCW_CW(KC_PGDN, KC_PGUP) },
    [_LAYER3] = { ENCODER_CCW_CW(KC_HOME, KC_END) }
};

#ifdef OLED_ENABLE
#include "timer.h"

static bool show_logo = true;
static uint16_t logo_start_time = 0;

const unsigned char epd_bitmap_untitled [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x2f, 0xf1, 0x61, 0xff, 0xff, 0xff, 0xff, 0x85, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x2f, 0xf1, 0x61, 0xff, 0xff, 0xff, 0xff, 0x85, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x0f, 0xf8, 0x71, 0xff, 0xff, 0xff, 0xff, 0xe5, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x71, 0xff, 0xff, 0xff, 0xff, 0xe5, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0xff, 0xf8, 0x73, 0xf9, 0xff, 0xff, 0xff, 0xe5, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x3f, 0x00, 0x73, 0xc2, 0x18, 0xe0, 0x7c, 0x05, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x3e, 0x00, 0x71, 0x82, 0x10, 0x60, 0x38, 0x05, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x2c, 0x01, 0x71, 0x06, 0x10, 0x7f, 0x18, 0x05, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x2c, 0x19, 0x70, 0x0f, 0x06, 0x70, 0x18, 0xe1, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x2c, 0x58, 0x70, 0x1f, 0x0e, 0x20, 0x00, 0xe1, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x2c, 0x50, 0x60, 0x0f, 0x0e, 0x21, 0x01, 0x81, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x18, 0x30, 0x00, 0x07, 0x0e, 0x03, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x07, 0x08, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x82, 0x00, 0x20, 0x83, 0x00, 0x30, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x87, 0x00, 0x60, 0x81, 0x00, 0x70, 0x8c, 0x11, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 
	0xfc, 0x00, 0xe8, 0x89, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xf2, 0xe3, 0xe0, 0x1f, 
	0xf8, 0x00, 0x40, 0x00, 0x3f, 0xff, 0xff, 0xfe, 0x07, 0xff, 0xff, 0xff, 0x80, 0x00, 0x40, 0x07, 
	0x00, 0x00, 0x00, 0x00, 0x2e, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x80, 0x00, 0x00, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xff, 0xff, 0xff, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

bool oled_task_user(void) {
    if (show_logo) {
        if (logo_start_time == 0) {
            logo_start_time = timer_read();
        }

        if (timer_elapsed(logo_start_time) < 3000) {
            oled_write_raw_P(epd_bitmap_untitled, sizeof(epd_bitmap_untitled));
            return false;
        } else {
            show_logo = false;
            oled_clear();
        }
    }

    oled_set_cursor(0, 0);
    oled_write_P(PSTR("LAYER:"), false);

    oled_set_cursor(7, 0);
    switch (active_layer) {
        case _BASE:
            oled_write_P(PSTR("BASE"), false);
            break;
        case _LAYER1:
            oled_write_P(PSTR("L1  "), false);
            break;
        case _LAYER2:
            oled_write_P(PSTR("L2  "), false);
            break;
        case _LAYER3:
            oled_write_P(PSTR("L3  "), false);
            break;
    }

    return false;
}
#endif

void keyboard_post_init_user(void) {
    gpio_set_pin_output(GP11);
    gpio_write_pin_high(GP11);
    rgblight_enable();
}
